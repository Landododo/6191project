Full-bypassing 4 stage processor divided into fetch, decode, execute, and writeback stages. 
ALU.ms: ALU description. Uses a recursive adder to add left half then right half and then add the 2 togther to be more efficient (though taking up more area).
CacheHelpers.ms: Does basic functions to get the bits used for certain RISC-V instructions like Sw and Sh and Sb....
CacheTypes.ms: Describes some request structures and some dictionaries to describe some status bits
Decode.ms: Extracts the different elements of an instruction (opcode, funct3,funct7, dst, src1,src2) and returns a decoded instruction type (DecodedInst) according to these values.
DirectMappedCache.ms: A direct-mapped cache implementation that sends instructions to the cache (defined in MainMemory.ms) and waits and updates cache according to instructions, handling hits, clean misses, and dirty misses.
Execute.ms: Takes in a decoded instruction and dest and source registers, and executes the instruction in the ALU. Also updates the nextPc according to the instruction. Finally returns an ExecInst which stores the nextPc and data resulting from executing the instruction.
MainMemory.ms: Not coded by me. Emulates DRAM technology and ensures data is properly stored and aligned. Also produces errors if multiple requests are made in 1 cycle. 
ProcTypes.ms: Specifies instruction actions as their instruction name instead of the bits representing it (like fnAdd instead of 3'b000). Also defines IType, DecodedInst, and BrFunc.
Processor.ms: Actual processor implementation. Pipelined into 4 stages: Fetch, decode, execute, and writeback. Fetch uses a direct mapped cache for instructions, issuing a request to the cache and updating the pc according to its input (fetch action along with redirect pc if it applies). Decode stage initiates a stall if necessary, otherwise attempts to bypass data from execute and writeback. Then just calls the decode function as outlined in Decode.ms. Also sets the fetch action to be executed and redirectPC if necessary. The execute stage executes the instruction according to the function described in Execute.ms, then issues write/load instructions to the data cache which is implemented as a 2-way set associative cache. Finally, the writeback stage writes back to the register files according to the result of the execute stage.
Annul (always predicts PC+4 and annuls if this isnt the case) and stall logic are also implemented throughout the processor with bypassing from execute and writeback to decode.
RegisterFile.ms: Not coded by me. Emulates registers ticking.
SRAM.ms: Not coded by me. Emulates SRAM which is used to implement main memory.
TwoWayCache.ms: Two way set associative cache that is used by the data cache of the processor. Handles hits, clean misses, and dirty misses and updates the cache accordingly. Uses lru eviction. 
